[1mdiff --git a/Openflow-Custom-Implementation/README.md b/Openflow-Custom-Implementation/README.md[m
[1mindex ed03f24..c740f6d 100644[m
[1m--- a/Openflow-Custom-Implementation/README.md[m
[1m+++ b/Openflow-Custom-Implementation/README.md[m
[36m@@ -4,9 +4,10 @@[m [mCustom implementation of the OpenFlow Software Defined Networking protocol. The[m
 By default the network created when the code is run is a fixed network, containing eight switches, one controller and four end nodes. The end nodes become aware of how to contact the network once contacted by their closest switch, but have no overall view of the network.[m
 [m
 ## Usage[m
[31m-1. Run the program containing all classes in the repository.[m
[31m-2. A seperate terminal window will open for each node in the network. Each terminal provides the user with output about that node. The terminals for *EndNodes* also take user input.[m
[31m-3. The *EndNodes* will prompt the user to wait for incoming messages or send messages.[m
[31m-4. Enter `WAIT` on whichever *EndNode* you would like to wait for a message. *EndNodes* can only receive a message when they are in the waiting state.[m
[31m-5. Enter `SEND` on whichever *EndNode* you would like to send a message from. Enter the letter associated with the destination node. Enter the message to be sent. If an *EndNode* tries to send a message to itself it will be dropped by the network. Otherwise, provided that the destination *EndNode* is waiting, the message will be received and visually outputted at the destination.[m
[31m-6. Information about the routing of the packet through the network will also be visible in the terminal window of any *Switch* that the packet is routed through.[m
[32m+[m[32m1. Compile the project in this directory. If using the command line, use `javac Controller.java`.[m
[32m+[m[32m2. Run the project. If using the command line, use `java Controller`.[m
[32m+[m[32m3. A seperate terminal window will open for each node in the network. Each terminal provides the user with output about that node. The terminals for *EndNodes* also take user input.[m
[32m+[m[32m4. The *EndNodes* will prompt the user to wait for incoming messages or send messages.[m
[32m+[m[32m5. Enter `WAIT` on whichever *EndNode* you would like to wait for a message. *EndNodes* can only receive a message when they are in the waiting state.[m
[32m+[m[32m6. Enter `SEND` on whichever *EndNode* you would like to send a message from. Enter the letter associated with the destination node. Enter the message to be sent. If an *EndNode* tries to send a message to itself it will be dropped by the network. Otherwise, provided that the destination *EndNode* is waiting, the message will be received and visually outputted at the destination.[m
[32m+[m[32m7. Information about the routing of the packet through the network will also be visible in the terminal window of any *Switch* that the packet is routed through.[m
\ No newline at end of file[m
[1mdiff --git a/Publish-Subscribe/README.md b/Publish-Subscribe/README.md[m
[1mindex 9263c60..269e1b7 100644[m
[1m--- a/Publish-Subscribe/README.md[m
[1m+++ b/Publish-Subscribe/README.md[m
[36m@@ -2,8 +2,8 @@[m
 Java implementation of a Publish-Subscribe protocol, which uses datagrams to communicate between a Subscriber, a Broker and a Publisher. The full report, [here](Publish-Subscribe-Report.pdf), details the entire technical specification of the project.[m
 [m
 ## Usage[m
[31m-1. Open a Java project containing all of the classes in the repository.[m
[31m-2. Run the *Broker*, the *Publisher* and the *Subscriber* seperately.[m
[32m+[m[32m1. Individually compile the *Broker*, *Publisher* and *Subscriber*. If using the command line, use `javac Broker.java`, `javac Publisher.java` and `javac Subscriber.java`.[m
[32m+[m[32m2. Run the *Broker*, the *Publisher* and the *Subscriber* seperately on the same machine. If using the command line, use `java Broker`, `java Publisher` and `java Subscriber`.[m
 3. The *Broker*, *Publisher* and *Subscriber* will each open up their terminal windows. Each window displays output to the user. The windows for the *Publisher* and *Subscriber* also take input.[m
 4. Enter `CREATE` in the *Publisher* window to create a topic. Enter the name of the topic you wish to create. Do this one or more times. The names of these topics are now stored in the *Broker*.[m
 5. Enter `SUBSCRIBE` in the *Subscriber* window. Enter the name of one of the topics that you have created. This subscription is noted by the *Broker*.[m
[1mdiff --git a/Web-Proxy-Server/README.md b/Web-Proxy-Server/README.md[m
[1mindex ea8d81c..87a9cf9 100644[m
[1m--- a/Web-Proxy-Server/README.md[m
[1m+++ b/Web-Proxy-Server/README.md[m
[36m@@ -6,10 +6,10 @@[m [mA Java implementation of a web proxy server which accepts a connection from a we[m
 2. Compile the project in this directory. If using the command line, use `javac ProxyMultiThread.java`.[m
 3. Run the project. If using the command line, use `java ProxyMultiThread`.[m
 4. Within the command line:[m
[31m-  - Enter HELP to see the list of possible commands.[m
[31m-  - Enter BLOCKED to view the list of blocked URLs.[m
[31m-  - Enter CACHED to view the list of cached webpages.[m
[31m-  - Enter CLOSE to close the proxy server.[m
[32m+[m[32m  - Enter `HELP` to see the list of possible commands.[m
[32m+[m[32m  - Enter `BLOCKED` to view the list of blocked URLs.[m
[32m+[m[32m  - Enter `CACHED` to view the list of cached webpages.[m
[32m+[m[32m  - Enter `CLOSE` to close the proxy server.[m
   - Otherwise, enter a URL to add it to the blocked list.[m
 5. Within your web browser:[m
   - Enter a previously accessed HTTP URL. The program will fetch it from the cache and return it to your browser.[m
